@startuml Airline_Management_System_Revised

' ==================== Styling Configuration ====================
skinparam classAttributeIconSize 0
skinparam linetype ortho
skinparam backgroundColor #FEFEFE
skinparam roundcorner 10
skinparam shadowing false

' Class styling
skinparam class {
  BackgroundColor<<Abstract>> #E8F5E9
  BackgroundColor<<Enum>> #FFF3E0
  BackgroundColor<<Singleton>> #E3F2FD
  BackgroundColor<<Entity>> #F3E5F5
  BackgroundColor<<Controller>> #FFE0B2
  BackgroundColor<<Utility>> #E0F2F1
  BackgroundColor<<Exception>> #FFEBEE
  BorderColor #424242
  ArrowColor #616161
  FontName Arial
  FontSize 11
}

skinparam nodesep 60
skinparam ranksep 80
skinparam packageStyle rectangle

' ==================== Core Infrastructure ====================

package "Core Infrastructure" {
  class GridDisplayConfig {
    + title: string
    + headerLines: vector<string>
    + legend: vector<string>
    + footerLines: vector<string>
    + showSeparator: bool
  }

  class UserInterface <<Singleton>> <<Utility>> {
    + {static} getInstance(): UserInterface*
    + print(message: string): void
    + println(message: string): void
    + printError(message: string): void
    + printSuccess(message: string): void
    + printWarning(message: string): void
    + printHeader(header: string): void
    + printSeparator(): void
    + getString(prompt: string): string
    + getInt(prompt: string): int
    + getDouble(prompt: string): double
    + getPassword(prompt: string): string
    + getChoice(prompt: string, min: int, max: int): int
    + getYesNo(prompt: string): bool
    + getDate(prompt: string, format: string): string
    + clearScreen(): void
    + pauseScreen(): void
    + displayMenu(title: string, options: vector<string>): void
    + displayTable(headers: vector<string>, rows: vector<vector<string>>): void
    + displayGrid(rowLabels: vector<string>, gridData: vector<vector<string>>, config: GridDisplayConfig): void
    + formatCurrency(amount: double): string
  }

  class Database <<Utility>> {
    + Database(filePath: string)
    + loadAll(): json
    + saveAll(data: json): void
    + getEntry(entryKey: string): json
    + addEntry(entryKey: string, entryData: json): void
    + deleteEntry(entryKey: string): void
    + entryExists(entryKey: string): bool
    + updateEntry(entryKey: string, updates: json): void
    + getAttribute(entryKey: string, attributeKey: string): auto
    + setAttribute(entryKey: string, attributeKey: string, value: json): void
    + deleteAttribute(entryKey: string, attributeKey: string): void
    + attributeExists(entryKey: string, attributeKey: string): bool
    + getEntryCount(): int
    + isEmpty(): bool
    + clear(): void
    + initializeIfNotExists(): void
  }

  enum DatabaseErrorCode <<Enum>> {
    FILE_NOT_FOUND
    FILE_READ_ERROR
    FILE_WRITE_ERROR
    INVALID_JSON
    ENTRY_NOT_FOUND
    ATTRIBUTE_NOT_FOUND
    DATABASE_ERROR
  }

  class DatabaseException <<Exception>> {
    + DatabaseException(code: DatabaseErrorCode)
    + what(): const char*
    + getErrorCode(): DatabaseErrorCode
  }

  class AirlineManagementSystem <<Singleton>> <<Controller>> {
    + {static} getInstance(): shared_ptr<AirlineManagementSystem>
    + initialize(): void
    + start(): void
    + displayWelcome(): void
    + manageFlights(): void
    + manageAircraft(): void
    + generateReports(): void
    + shutdown(): void
  }
  
  UserInterface --> GridDisplayConfig : uses
  Database ..> DatabaseException : throws
  DatabaseException --> DatabaseErrorCode
  AirlineManagementSystem --> UserInterface : uses
}

' ==================== User Management ====================

package "User Management" {
  enum UserRole <<Enum>> {
    ADMINISTRATOR
    BOOKING_AGENT
    PASSENGER
  }

  enum UserErrorCode <<Enum>> {
    USERNAME_TAKEN
    INVALID_USERNAME
    INVALID_PASSWORD
    USER_NOT_FOUND
    INCORRECT_PASSWORD
    DATABASE_ERROR
    INVALID_INPUTS
  }

  abstract class User <<Abstract>> {
    # username: string
    + {static} initializeUserSystem(): void
    + {static} login(username: string, password: string): unique_ptr<User>
    + {abstract} displayMenu(): void
    + {abstract} handleMenuChoice(choice: int): void
    + logout(): void
    + getUsername(): string
    + getName(): string
    + getRole(): UserRole
    + getEmail(): string
    + getPhoneNumber(): string
    + setName(name: string): void
    + setEmail(email: string): void
    + setPhoneNumber(phoneNumber: string): void
  }

  class Administrator {
    + displayMenu(): void
    + handleMenuChoice(choice: int): void
  }

  class BookingAgent {
    + displayMenu(): void
    + handleMenuChoice(choice: int): void
  }

  class Passenger {
    + displayMenu(): void
    + handleMenuChoice(choice: int): void
    + viewBookingHistory(): void
    + viewCurrentBookings(): void
    + viewBoardingPasses(): void
  }

  class UserException <<Exception>> {
    + UserException(code: UserErrorCode)
    + what(): const char*
    + getErrorCode(): UserErrorCode
  }
  
  User <|-- Administrator
  User <|-- BookingAgent
  User <|-- Passenger
  User --> UserRole
  User ..> UserException : throws
  User --> Database : uses
  User --> UserInterface : uses
  UserException --> UserErrorCode
}

' ==================== Seat Map Management ====================

package "Seat Map Management" {
  enum SeatMapErrorCode <<Enum>> {
    INVALID_SEAT
    SEAT_ALREADY_RESERVED
    SEAT_NOT_FOUND
    INVALID_LAYOUT
    INVALID_ROWS
  }

  class SeatMap <<Utility>> {
    - seatLayout: string
    - rows: int
    - reservedSeats: vector<string>
    + SeatMap(seatLayout: string, rows: int)
    + SeatMap(seatLayout: string, rows: int, reservedSeats: vector<string>)
    + {static} initializeSeatMapSystem(): void
    + {static} validateSeatLayout(layout: string): bool
    + {static} generateSeatMap(seatLayout: string, rows: int): vector<string>
    + {static} calculateSeatCount(seatLayout: string, rows: int): int
    + {static} getSeatsPerRow(seatLayout: string): int
    + {static} getSampleSeatMapDisplayData(seatLayout: string, rows: int, rowLabels: vector<string>&, gridData: vector<vector<string>>&, displayRows: int): void
    + {static} getSampleSeatMapFooter(seatLayout: string, rows: int): vector<string>
    + isValidSeat(seatNumber: string): bool
    + getAllSeats(): vector<string>
    + reserveSeat(seatNumber: string): bool
    + releaseSeat(seatNumber: string): bool
    + isSeatAvailable(seatNumber: string): bool
    + getReservedSeats(): vector<string>
    + getAvailableSeatsCount(): int
    + getTotalSeatsCount(): int
    + getSeatMapDisplayData(rowLabels: vector<string>&, gridData: vector<vector<string>>&): void
    + getSeatMapHeader(flightNumber: string, origin: string, destination: string, aircraftType: string): vector<string>
    + getSeatMapLegend(): vector<string>
    + getSeatMapFooter(): vector<string>
  }

  class SeatMapException <<Exception>> {
    + SeatMapException(code: SeatMapErrorCode)
    + SeatMapException(code: SeatMapErrorCode, info: string)
    + what(): const char*
    + getErrorCode(): SeatMapErrorCode
  }

  SeatMap ..> SeatMapException : throws
  SeatMapException --> SeatMapErrorCode
}

' ==================== Aircraft Management ====================

package "Aircraft Management" {
  enum AircraftErrorCode <<Enum>> {
    AIRCRAFT_NOT_FOUND
    AIRCRAFT_EXISTS
    INVALID_AIRCRAFT_TYPE
    INVALID_SEAT_LAYOUT
    INVALID_SEAT_NUMBER
    DATABASE_ERROR
  }

  class Aircraft <<Entity>> {
    - aircraftType: string
    + Aircraft()
    + Aircraft(aircraftType: string)
    + {static} initializeAircraftSystem(): void
    + {static} manageAircraft(): void
    + {static} getAllAircraftTypes(): vector<string>
    + {static} aircraftTypeExists(aircraftType: string): bool
    + getAircraftType(): string
    + getManufacturer(): string
    + getModel(): string
    + getTotalSeats(): int
    + getSeatLayout(): string
    + getRows(): int
    + getFleetCount(): int
    + getStatus(): string
    + setManufacturer(manufacturer: string): void
    + setModel(model: string): void
    + setTotalSeats(seats: int): void
    + setSeatLayout(layout: string): void
    + setRows(rows: int): void
    + setFleetCount(count: int): void
    + setStatus(status: string): void
    + displayAircraftInfo(): void
  }

  class AircraftException <<Exception>> {
    + AircraftException(code: AircraftErrorCode)
    + what(): const char*
    + getErrorCode(): AircraftErrorCode
  }
  
  Aircraft --> Database : uses
  Aircraft --> UserInterface : uses
  Aircraft ..> SeatMap : uses
  Aircraft ..> AircraftException : throws
  AircraftException --> AircraftErrorCode
}

' ==================== Flight Management ====================

package "Flight Management" {
  enum FlightErrorCode <<Enum>> {
    FLIGHT_NOT_FOUND
    FLIGHT_EXISTS
    INVALID_FLIGHT_NUMBER
    INVALID_AIRCRAFT_TYPE
    DATABASE_ERROR
  }

  class Flight <<Entity>> {
    - flightNumber: string
    + Flight()
    + Flight(flightNumber: string)
    + {static} initializeFlightSystem(): void
    + {static} manageFlights(): void
    + {static} searchFlights(origin: string, destination: string, date: string): vector<unique_ptr<Flight>>
    + getFlightNumber(): string
    + getOrigin(): string
    + getDestination(): string
    + getDepartureDateTime(): string
    + getArrivalDateTime(): string
    + getAircraftType(): string
    + getStatus(): string
    + getPrice(): double
    + getTotalSeats(): int
    + getAvailableSeats(): int
    + getGate(): string
    + getBoardingTime(): string
    + setStatus(status: string): void
    + setPrice(price: double): void
    + setGate(gate: string): void
    + setBoardingTime(boardingTime: string): void
    + getReservedSeats(): vector<string>
    + reserveSeat(seatNumber: string): bool
    + releaseSeat(seatNumber: string): bool
    + isSeatAvailable(seatNumber: string): bool
    + displaySeatMap(): void
    + displayFlightInfo(): void
  }

  class FlightException <<Exception>> {
    + FlightException(code: FlightErrorCode)
    + what(): const char*
    + getErrorCode(): FlightErrorCode
  }
  
  Flight --> Database : uses
  Flight --> UserInterface : uses
  Flight ..> Aircraft : queries
  Flight ..> SeatMap : uses
  Flight ..> FlightException : throws
  FlightException --> FlightErrorCode
}

' ==================== Crew Management ====================

package "Crew Management" {
  enum CrewRole <<Enum>> {
    PILOT
    FLIGHT_ATTENDANT
  }

  class CrewMember <<Entity>> {
    + CrewMember()
    + CrewMember(crewId: string)
    + {static} initializeCrewSystem(): void
    + {static} manageCrew(): void
    + {static} getAvailableCrew(role: CrewRole, date: string): vector<unique_ptr<CrewMember>>
    + {static} assignCrewToFlight(crewId: string, flightNumber: string): bool
    + {static} unassignCrewFromFlight(crewId: string, flightNumber: string): bool
    + getCrewId(): string
    + getName(): string
    + getRole(): CrewRole
    + getLicenseNumber(): string
    + getFlightHours(): double
    + getAssignedFlights(): vector<string>
    + setName(name: string): void
    + setLicenseNumber(license: string): void
    + addFlightHours(hours: double): void
    + canBeAssigned(date: string): bool
    + displayInfo(): void
  }
  
  CrewMember --> CrewRole
}

' ==================== Booking System ====================

package "Booking System" {
  enum ReservationStatus <<Enum>> {
    PENDING
    CONFIRMED
    CHECKED_IN
    BOARDED
    COMPLETED
    CANCELED
  }

  class Reservation <<Entity>> {
    + Reservation(passengerUsername: string, flightNumber: string, seatNumber: string)
    + Reservation(reservationId: string)
    + {static} initializeReservationSystem(): void
    + {static} getPassengerReservations(passengerUsername: string): vector<unique_ptr<Reservation>>
    + {static} getFlightReservations(flightNumber: string): vector<unique_ptr<Reservation>>
    + getReservationId(): string
    + getPassengerUsername(): string
    + getPassengerName(): string
    + getFlightNumber(): string
    + getSeatNumber(): string
    + getStatus(): ReservationStatus
    + getBookingDate(): string
    + getTotalCost(): double
    + getPaymentId(): string
    + confirmReservation(): void
    + cancelReservation(): void
    + checkIn(): void
    + setStatus(status: ReservationStatus): void
    + displayReservationInfo(): void
  }

  enum PaymentMethod <<Enum>> {
    CREDIT_CARD
    DEBIT_CARD
    CASH
    PAYPAL
  }

  enum TransactionStatus <<Enum>> {
    PENDING
    COMPLETED
    FAILED
    REFUNDED
  }

  class Payment {
    + Payment(reservationId: string, amount: double, method: PaymentMethod)
    + Payment(paymentId: string)
    + {static} initializePaymentSystem(): void
    + getPaymentId(): string
    + getReservationId(): string
    + getAmount(): double
    + getPaymentMethod(): PaymentMethod
    + getTransactionStatus(): TransactionStatus
    + getPaymentDate(): string
    + processPayment(): bool
    + refund(): bool
    + displayPaymentInfo(): void
  }

  class BoardingPass {
    + BoardingPass(reservationId: string)
    + {static} generateBoardingPass(reservationId: string): unique_ptr<BoardingPass>
    + getBoardingPassId(): string
    + getReservationId(): string
    + getPassengerName(): string
    + getFlightNumber(): string
    + getSeatNumber(): string
    + getGate(): string
    + getBoardingTime(): string
    + displayBoardingPass(): void
    + verify(): bool
  }

  class CheckInSystem {
    + {static} checkInPassenger(reservationId: string): unique_ptr<BoardingPass>
    + {static} verifyBoardingPass(boardingPassId: string): bool
  }
  
  Reservation --> ReservationStatus
  Payment --> PaymentMethod
  Payment --> TransactionStatus
  CheckInSystem ..> BoardingPass : creates
}

' ==================== Reporting ====================

package "Reporting" {
  class ReportGenerator <<Controller>> {
    + {static} generateReports(): void
    + {static} generateFlightReport(): void
    + {static} generateRevenueReport(): void
    + {static} generateMaintenanceReport(): void
    + {static} generateCrewUtilizationReport(): void
  }
  
  ReportGenerator --> UserInterface : uses
}

' ==================== Cross-Package Relationships ====================

' System orchestrates major components
AirlineManagementSystem --> Flight : delegates to
AirlineManagementSystem --> Aircraft : delegates to
AirlineManagementSystem --> ReportGenerator : delegates to

' User classes interact with system
Administrator --> AirlineManagementSystem : uses
BookingAgent --> AirlineManagementSystem : uses
Passenger --> AirlineManagementSystem : uses

' Data flow relationships
Reservation --> Flight : references
Reservation --> Payment : has
BoardingPass --> Reservation : generated from
CrewMember ..> Flight : assigned to

note top of AirlineManagementSystem
  **Singleton Pattern - Central Orchestrator**
  - Does NOT store domain data
  - Delegates operations to domain classes
  - Each domain class manages its own JSON
  - manageFlights() -> Flight::manageFlights()
  - manageAircraft() -> Aircraft::manageAircraft()
  - generateReports() -> ReportGenerator::generateReports()
end note

note right of SeatMap
  **Pure Business Logic Class**
  - NO database or UI dependencies
  - Validates seat layouts and seat numbers
  - Manages seat reservations in memory
  - Returns display data structures
  - Used by both Aircraft and Flight classes
  
  **Static Methods:**
  - Generate seat maps from layout
  - Validate seat configurations
  - Calculate seat counts
  
  **Instance Methods:**
  - Track specific flight reservations
  - Validate individual seats
  - Return display data for UI
end note

note right of Flight
  **Self-Managing Entity**
  Database: Flights.json
  Structure: {
    "FL123": {
      "origin": "NYC",
      "destination": "LAX",
      "aircraftType": "Boeing737",
      "reservedSeats": ["1A", "2B"],
      "price": 299.99,
      "status": "SCHEDULED",
      ...
    }
  }
  - Queries Aircraft for seat configuration
  - Creates SeatMap instances with reservations
  - Manages seat bookings per flight
  - Each flight has independent reservations
end note

note right of Aircraft
  **Aircraft Type Registry**
  Database: Aircraft.json
  Structure: {
    "Boeing737": {
      "manufacturer": "Boeing",
      "model": "737-800",
      "totalSeats": 180,
      "seatLayout": "3-3",
      "rows": 30,
      "fleetCount": 15,
      "status": "AVAILABLE",
      ...
    }
  }
  - Stores aircraft TYPE specifications
  - Defines seat layout and capacity
  - Uses SeatMap for validation
  - Uses UI grid display for seat maps
end note

note left of UserInterface
  **Generic Grid Display**
  - displayGrid() can render any 2D data
  - Used by SeatMap for seat displays
  - Configurable with GridDisplayConfig
  - Handles all formatting and alignment
  - Reusable for other grid-based displays
end note

note bottom of User
  **User Management**
  Database: Users.json
  Structure: {
    "john_doe": {
      "passwordHash": "...",
      "role": 2,
      "name": "John Doe",
      "email": "john@example.com",
      "phoneNumber": "555-1234",
      ...
    }
  }
  - Username as primary key
  - Role-based polymorphism
  - Password hashing for security
  - First-time setup creates admin
end note

note left of Reservation
  **Booking Records**
  Database: Reservations.json
  Structure: {
    "RES001": {
      "passengerUsername": "john_doe",
      "flightNumber": "FL123",
      "seatNumber": "12A",
      "status": "CONFIRMED",
      "paymentId": "PAY001",
      "bookingDate": "2024-01-15",
      ...
    }
  }
  - Links passenger to flight + seat
  - Coordinates with Flight for availability
  - Triggers Payment creation
  - Passengers query by username
end note

@enduml